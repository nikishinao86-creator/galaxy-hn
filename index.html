<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hunter Network</title>

  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js?59"></script>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: sans-serif;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      pointer-events: none;
      z-index: 1;
      font-size: 14px;
      text-shadow: 0 0 5px #000;
    }
  </style>
</head>
<body>
  <div id="info">üåå –ó–∞–≥—Ä—É–∑–∫–∞ –≥–∞–ª–∞–∫—Ç–∏–∫–∏...</div>

  <script>
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram
    const tg = Telegram.WebApp;
    tg.ready();
    tg.expand();

    const user = tg.initDataUnsafe.user;
    document.getElementById("info").textContent = `üåå ${user.first_name}, –≤–∞—à–∞ –≥–∞–ª–∞–∫—Ç–∏–∫–∞`;

    // --- Three.js —Å—Ü–µ–Ω–∞ ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000011);
    document.body.appendChild(renderer.domElement);

    // –ó–≤—ë–∑–¥–Ω—ã–π —Ñ–æ–Ω
    const starsGeometry = new THREE.BufferGeometry();
    const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
    const starsVertices = [];
    for (let i = 0; i < 10000; i++) {
      const x = THREE.MathUtils.randFloatSpread(200);
      const y = THREE.MathUtils.randFloatSpread(200);
      const z = THREE.MathUtils.randFloatSpread(200);
      starsVertices.push(x, y, z);
    }
    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∑–≤–µ–∑–¥–∞ ‚Äî —Ç—ã
    const starGeometry = new THREE.SphereGeometry(1, 64, 64);
    const starMaterial = new THREE.MeshBasicMaterial({
      color: 0xffd700,
      emissive: 0xffa500,
      emissiveIntensity: 1.5
    });
    const star = new THREE.Mesh(starGeometry, starMaterial);
    scene.add(star);

    // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–ª–∞–Ω–µ—Ç
    const planets = [];

    // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Ä–æ–≤–Ω–µ–π (15)
    const levels = 15;

    // –ò–º–∏—Ç–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö: —Å–∫–æ–ª—å–∫–æ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ —É –∫–∞–∂–¥–æ–π –ø–ª–∞–Ω–µ—Ç—ã (–Ω–∞ 1-–º —É—Ä–æ–≤–Ω–µ)
    // –í –±—É–¥—É—â–µ–º —ç—Ç–æ –±—É–¥–µ—Ç —Å —Å–µ—Ä–≤–µ—Ä–∞
    const referralsCount = [3, 0, 7, 1, 12, 2, 5, 0, 8, 3, 9, 4, 6, 1, 10];

    for (let level = 0; level < levels; level++) {
      const orbitRadius = 4 + level * 3; // –†–∞–¥–∏—É—Å –æ—Ä–±–∏—Ç—ã

      // –û—Ä–±–∏—Ç–∞–ª—å–Ω–æ–µ –∫–æ–ª—å—Ü–æ
      const orbitGeometry = new THREE.RingGeometry(orbitRadius - 0.1, orbitRadius + 0.1, 32);
      const orbitMaterial = new THREE.MeshBasicMaterial({
        color: 0x4444ff,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
      orbit.rotation.x = Math.PI / 2;
      scene.add(orbit);

      // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ —É —ç—Ç–æ–π –ø–ª–∞–Ω–µ—Ç—ã
      const refCount = referralsCount[level]; // –æ—Ç 0 –¥–æ 12

      // –ú–∞—Ç–µ—Ä–∏–∞–ª: –±–µ–ª–∞—è –ø–ª–∞–Ω–µ—Ç–∞
      const planetMaterial = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        emissive: 0x444444,
        shininess: 30
      });

      const planetGeometry = new THREE.SphereGeometry(0.5, 32, 32);
      const planet = new THREE.Mesh(planetGeometry, planetMaterial);

      // –ù–∞—á–∞–ª—å–Ω—ã–π —É–≥–æ–ª
      const angle = Math.random() * Math.PI * 2;

      planet.position.x = Math.cos(angle) * orbitRadius;
      planet.position.z = Math.sin(angle) * orbitRadius;
      scene.add(planet);

      // –°–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —á–∏—Å–ª–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤
      // –ß–µ–º –±–æ–ª—å—à–µ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ ‚Äî —Ç–µ–º –±—ã—Å—Ç—Ä–µ–µ
      const baseSpeed = 0.002;
      const speed = baseSpeed + (refCount / 100); // –ù–∞–ø—Ä–∏–º–µ—Ä: 0.002 –¥–æ 0.014

      planets.push({
        mesh: planet,
        radius: orbitRadius,
        angle: angle,
        speed: speed,
        refCount: refCount
      });
    }

    // –ö–∞–º–µ—Ä–∞: –≤–∏–¥ —Å–≤–µ—Ä—Ö—É
    camera.position.set(0, 50, 0);
    camera.lookAt(0, 0, 0);
    camera.up.set(0, 0, 1);

    // –ê–Ω–∏–º–∞—Ü–∏—è
    function animate() {
      requestAnimationFrame(animate);

      // –í—Ä–∞—â–µ–Ω–∏–µ –∑–≤–µ–∑–¥—ã
      star.rotation.y += 0.002;

      // –î–≤–∏–∂–µ–Ω–∏–µ –ø–ª–∞–Ω–µ—Ç –ø–æ –æ—Ä–±–∏—Ç–∞–º
      planets.forEach(p => {
        p.angle += p.speed;
        p.mesh.position.x = Math.cos(p.angle) * p.radius;
        p.mesh.position.z = Math.sin(p.angle) * p.radius;
        p.mesh.rotation.y += 0.005; // –ª—ë–≥–∫–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ —Å–≤–æ–µ–π –æ—Å–∏
      });

      renderer.render(scene, camera);
    }
    animate();

    // –ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø–æ–¥ —Ä–∞–∑–º–µ—Ä —ç–∫—Ä–∞–Ω–∞
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
