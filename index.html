<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Hunter Network</title>

  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js?59"></script>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      cursor: default;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      pointer-events: none;
      z-index: 1;
      font-size: 14px;
      text-shadow: 0 0 5px #000;
      font-weight: 500;
    }
    .level-label {
      position: absolute;
      color: #aaa;
      font-size: 10px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="info">üåå –ó–∞–≥—Ä—É–∑–∫–∞ –≥–∞–ª–∞–∫—Ç–∏–∫–∏...</div>

  <script>
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram
    const tg = Telegram.WebApp;
    tg.ready();
    tg.expand();

    const user = tg.initDataUnsafe.user;
    document.getElementById("info").textContent = `üåå ${user.first_name}, –≤–∞—à–∞ —Å–µ—Ç—å`;

    // --- Three.js —Å—Ü–µ–Ω–∞ ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000011);
    document.body.appendChild(renderer.domElement);

    // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∑–≤–µ–∑–¥–∞ ‚Äî —Ç—ã
    const starGeometry = new THREE.SphereGeometry(1, 64, 64);
    const starMaterial = new THREE.MeshBasicMaterial({
      color: 0xffd700,
      emissive: 0xffa500,
      emissiveIntensity: 1.5
    });
    const star = new THREE.Mesh(starGeometry, starMaterial);
    scene.add(star);

    // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–ª–∞–Ω–µ—Ç
    const planets = [];

    // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Ä–æ–≤–Ω–µ–π ‚Äî 15
    const levels = 15;

    // –ò–º–∏—Ç–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö: —Ä–µ—Ñ–µ—Ä–∞–ª—ã –Ω–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ
    const referralsCount = [3, 0, 7, 1, 12, 2, 5, 0, 8, 3, 9, 4, 6, 1, 10];

    // –¶–≤–µ—Ç–∞ –æ—Ä–±–∏—Ç
    const orbitColors = [
      0xffffff, 0x4488ff, 0x88ff44, 0xff8844, 0xffcc00,
      0xcc00ff, 0x00ffff, 0xff66cc, 0x66ff66, 0x44aaff,
      0xffaa00, 0xaa00aa, 0x00ccff, 0xcc6600, 0x9999ff
    ];

    for (let level = 0; level < levels; level++) {
      const orbitRadius = 4 + level * 3;

      // –û—Ä–±–∏—Ç–∞–ª—å–Ω–æ–µ –∫–æ–ª—å—Ü–æ
      const orbitGeometry = new THREE.RingGeometry(orbitRadius - 0.1, orbitRadius + 0.1, 32);
      const orbitMaterial = new THREE.MeshBasicMaterial({
        color: orbitColors[level],
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide
      });
      const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
      orbit.rotation.x = Math.PI / 2;
      scene.add(orbit);

      // –ë–µ–ª–∞—è –ø–ª–∞–Ω–µ—Ç–∞
      const planetGeometry = new THREE.SphereGeometry(0.5, 32, 32);
      const planetMaterial = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        emissive: 0x333333,
        shininess: 30
      });
      const planet = new THREE.Mesh(planetGeometry, planetMaterial);

      // –°–ª—É—á–∞–π–Ω—ã–π —Å—Ç–∞—Ä—Ç–æ–≤—ã–π —É–≥–æ–ª
      const angle = Math.random() * Math.PI * 2;
      planet.position.x = Math.cos(angle) * orbitRadius;
      planet.position.z = Math.sin(angle) * orbitRadius;
      scene.add(planet);

      // –°–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —á–∏—Å–ª–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤
      const baseSpeed = 0.002;
      const speed = baseSpeed + (referralsCount[level] / 100);

      // –î–∞–Ω–Ω—ã–µ –ø–ª–∞–Ω–µ—Ç—ã
      planet.userData = {
        level: level + 1,
        referrals: referralsCount[level],
        radius: orbitRadius,
        angle: angle,
        speed: Math.max(speed, 0.0005),
        isHovered: false
      };

      planets.push(planet);

      // –ú–µ—Ç–∫–∞ —É—Ä–æ–≤–Ω—è
      const label = document.createElement('div');
      label.className = 'level-label';
      label.textContent = `L${level + 1}`;
      label.dataset.level = level;
      document.body.appendChild(label);
    }

    // --- –ö–∞–º–µ—Ä–∞: –≤–∏–¥ —Å–≤–µ—Ä—Ö—É ---
    let cameraZ = 50;
    const minZoom = 20;
    const maxZoom = 100;
    camera.position.set(0, cameraZ, 0);
    camera.lookAt(0, 0, 0);
    camera.up.set(0, 0, 1);

    // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª—ë—Å–∏–∫–æ–º (zoom) ---
    function handleWheel(event) {
      event.preventDefault();
      cameraZ += event.deltaY * 0.05;
      cameraZ = Math.max(minZoom, Math.min(maxZoom, cameraZ));
      camera.position.y = cameraZ;
    }
    renderer.domElement.addEventListener('wheel', handleWheel, { passive: false });

    // --- Raycaster –¥–ª—è hover –∏ –∫–ª–∏–∫–∞ ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // –•—Ä–∞–Ω–µ–Ω–∏–µ –ø–ª–∞–Ω–µ—Ç—ã –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
    let hoveredPlanet = null;

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(planets);
      const planet = intersects.length > 0 ? intersects[0].object : null;

      // –ï—Å–ª–∏ –Ω–∞–≤–µ–ª–∏ –Ω–∞ –¥—Ä—É–≥—É—é –ø–ª–∞–Ω–µ—Ç—É
      if (planet !== hoveredPlanet) {
        // –°–±—Ä–æ—Å –ø—Ä–µ–¥—ã–¥—É—â–µ–π
        if (hoveredPlanet) {
          hoveredPlanet.userData.isHovered = false;
          document.body.style.cursor = 'default';
        }
        // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–æ–≤–æ–π
        if (planet) {
          hoveredPlanet = planet;
          planet.userData.isHovered = true;
          document.body.style.cursor = 'pointer';
        } else {
          hoveredPlanet = null;
        }
      }
    }

    function onMouseClick(event) {
      if (hoveredPlanet) {
        const data = hoveredPlanet.userData;
        tg.showPopup({
          title: `–£—Ä–æ–≤–µ–Ω—å ${data.level}`,
          message: `–†–µ—Ñ–µ—Ä–∞–ª—ã: ${data.referrals}\n–£—Ä–æ–≤–µ–Ω—å: ${data.level}`,
          buttons: [{ type: "ok" }]
        });
      }
    }

    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('click', onMouseClick);

    // --- –ê–Ω–∏–º–∞—Ü–∏—è ---
    function animate() {
      requestAnimationFrame(animate);

      // –í—Ä–∞—â–µ–Ω–∏–µ –∑–≤–µ–∑–¥—ã
      star.rotation.y += 0.002;

      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç–æ–∫ –∏ –≤—Ä–∞—â–µ–Ω–∏—è –ø–ª–∞–Ω–µ—Ç
      planets.forEach(planet => {
        const data = planet.userData;

        // –ë–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
        let effectiveSpeed = data.speed;

        // –ó–∞–º–µ–¥–ª–µ–Ω–∏–µ –ø—Ä–∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–∏ (—á–µ–º –±–ª–∏–∂–µ ‚Äî —Ç–µ–º –º–µ–¥–ª–µ–Ω–Ω–µ–µ)
        const zoomFactor = 1 - (cameraZ - minZoom) / (maxZoom - minZoom);
        effectiveSpeed *= (1 - zoomFactor * 0.8); // –Ω–∞ max zoom ‚Äî 80% –∑–∞–º–µ–¥–ª–µ–Ω–∏—è

        // –ü–æ–ª–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
        if (data.isHovered) {
          effectiveSpeed = 0;
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É–≥–ª–∞
        data.angle += effectiveSpeed;
        planet.position.x = Math.cos(data.angle) * data.radius;
        planet.position.z = Math.sin(data.angle) * data.radius;
        planet.rotation.y += 0.005 * (effectiveSpeed / data.speed); // –≤—Ä–∞—â–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ –æ—Å–∏ —Ç–æ–∂–µ –∑–∞–º–µ–¥–ª—è–µ—Ç—Å—è
      });

      renderer.render(scene, camera);
      updateLabels();
    }

    // --- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç–æ–∫ —É—Ä–æ–≤–Ω–µ–π ---
    function updateLabels() {
      const rect = renderer.domElement.getBoundingClientRect();
      planets.forEach((planet, i) => {
        const label = document.querySelector(`.level-label[data-level="${i}"]`);
        if (!label) return;

        const worldPos = planet.position.clone();
        const vector = worldPos.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

        const isInView = camera.position.clone().sub(worldPos).dot(new THREE.Vector3(0, -1, 0)) > 0;
        label.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
        label.style.opacity = isInView ? 1 : 0;
      });
    }

    // --- –ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø–æ–¥ —Ä–∞–∑–º–µ—Ä —ç–∫—Ä–∞–Ω–∞ ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // –ó–∞–ø—É—Å–∫
    animate();
  </script>
</body>
</html>
